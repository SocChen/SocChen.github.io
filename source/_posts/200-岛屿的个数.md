---
title: 200. 岛屿的个数
date: 2019-04-02 23:34:58
tags: [Leetcode,图,DFS,BFS]
categories: [Leetcode解题报告]
---

# 200. 岛屿的个数
给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。

## 示例 1:

>输入:  
>11110  
>11010  
>11000  
>00000  
>输出: 1

## 示例 2:
>输入:  
11000   
11000   
00100  
00011  
>
>输出: 3
***
## 思路
连通块问题。就是给定一个图，求连通分量的数目。输入的数据可以用二维的数组或二维向量储存。每次从“1”的块（即“陆地”）出发，遍历与其相连的“陆地”，并将遍历过的“陆地”的值置为“0”，表示其与“海洋”一样，无须遍历，以避免多次访问同一个“块”。遍历的算法可以使用DFS遍历或BFS遍历。

***
## 代码
#### **DFS遍历**
```c++
//执行时间20ms,内存消耗10.5MB
#include <iostream>
#include <vector>
#include <cstdio>
using namespace std;

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int cnt=0;
        for(int i=0; i<grid.size(); i++){
            for(int j=0; j<grid[i].size(); j++){
                if(grid[i][j] != '0'){
                    cnt++;
                    dfs(grid, i, j);
                }
            }
        }
        return cnt;
    }

    void dfs(vector<vector<char>>& grid,int x,int y){
        if( x<0 || x>=grid.size() || y<0 || y>=grid[x].size() ) return;
        if( grid[x][y] =='0' ) return;
        grid[x][y] = '0';
        dfs(grid, x-1, y) ;
        dfs(grid, x+1, y) ;
        dfs(grid, x, y-1) ;
        dfs(grid, x, y+1) ;
    }
};

int main(){

    freopen("input", "r", stdin);
    freopen("output", "w", stdout);

    char str;
    vector< vector< char > > a;
    vector< char > t;
    while( cin.get(str) ){
        if(str!='\n')
            t.push_back(str);
        else{
            a.push_back(t);
            t.clear();
        }
    }
    Solution s;
    cout << s.numIslands(a) << endl;
}
```

#### **BFS遍历**
```c++
// 在Leetcode上只通过了38个测试用例，错误为超时
#include<iostream>
#include<vector>
#include<queue>
#include<cmath>
#include<string>

using namespace std;

class Solution {
private:
    int count=0;
    pair<int,int> subnode;
    pair<int, int> node;
    int m[4][2]={1,0,0,1,-1,0,0,-1};

public:
    int numIslands(vector<vector<char>>& grid) {
        for(int i=0; i<grid.size(); i++){
            for(int j=0; j<grid[i].size(); j++){
                if( grid[i][j] == '0' ) continue;
                else {
                    node.first = i;
                    node.second = j;
                    bfs(grid, node);
                    count++;
                }
            }
        }
        return count;
    }

private:
    void bfs(vector<vector<char>>& grid, pair<int,int>& node ){
        queue< pair<int ,int> > q;
        pair<int, int> qhead;
        q.push( node );
        while( !q.empty() ){
            qhead = q.front();
            grid[ qhead.first ][ qhead.second ]='0';
            q.pop();
            for(int i=0; i<4; i++){
                int x = qhead.first + m[i][0];
                int y = qhead.second + m[i][1];
                if( x<0 || x>=grid.size() || y<0 || y>=grid[x].size() ) continue;
                if( grid[x][y] == '1'){
                    subnode.first = x;
                    subnode.second = y;
                    q.push( subnode );
                }
            }
        }
    }
};

int main(){

    freopen("input2", "r", stdin);
    freopen("output", "w", stdout);

    char str;
    vector< vector< char > > a;
    vector< char > t;
    while( cin.get(str) ){
        if(str!='\n')
            t.push_back(str);
        else{
            a.push_back(t);
            t.clear();
        }
    }
    Solution s;
    cout << s.numIslands(a) << endl;
}
```

#### **BFS遍历（修改）**
```c++
//与上面相比，仅仅是修改了grid[x][y]='0'的位置
//执行用时36ms，内存消耗11MB
void bfs(vector<vector<char>>& grid,pair<int,int>& node ){
    queue< pair<int ,int> > q;
    pair<int, int> qhead;
    q.push( node );
    while( !q.empty() ){
        qhead = q.front();
        q.pop();
        for(int i=0; i<4; i++){
            int x = qhead.first + m[i][0];
            int y = qhead.second + m[i][1];
            if( x<0 || x>=grid.size() || y<0 || y>=grid[x].size() ) continue;
            if( grid[x][y] == '1'){
                subnode.first = x;
                subnode.second = y;
                q.push( subnode );
                grid[ x ][ y ]='0';
            }
        }
    }
}
```