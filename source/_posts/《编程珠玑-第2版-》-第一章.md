---
title: 《编程珠玑(第2版)》 第一章
date: 2019-08-09 20:45:54
tags: [编程珠玑,排序]
categories: [编程珠玑]
mathjax: true
---

## 背景

​近日正在阅读《编程珠玑(第2版)》，希望自己能有所收获。《编程珠玑》的内容丰富，每章的后面都有一定量的习题。这篇文章不是为了记录习题的答案而写，仅仅会包含我在学习中觉得对自己有帮助和我觉得有趣的内容。

## 问题描述

**输入**
一个最多包含n个正整数的文件，每个数都小于n，其中$n = 10^7$。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。

<!-- more -->

**输出**
按升序排列的输入整数的列表

**约束**
最多有（大约）1MB的内存空间可用，有充足的磁盘存储空间可用。运行时间最多几分钟，运行时间为10秒就不需要进一步优化了。

## 简单分析
&emsp;&emsp;这个问题的难点是内存空间的限制，其次是时间的限制。《编程珠玑》中给的思路是将数据集合用位图或者位向量表示。

&emsp;&emsp;使用位图表示1000万个数，需要125万字节。如果问题的约束严格限制在1MB以内，可以采用两趟算法。即第一趟排序0~49999999的数字，第二趟排序5000000~9999999中间的数据。使用C语言来实现的话，关键点只需将存储数据的数组的大小设置成5000000就行。k趟算法同理，时间开销变成了kn，空间开销变成n/k。

&emsp;&emsp;下面给出的程序，没有严格考虑内存在1MB以内。只是用位图实现了排序。

## 测试数据

我是用python代码自动生成测试数据的文件
```python
# 文件名：dataGenerator.py
# 示例：  dataGenerator.py 10000 1
# 示例表示生成由10000个数据构成的文件，并且每个数据最多出现1次
import random
import sys
args = sys.argv
k = args[1]
max_of_per_num = eval(args[2])
N = 10000000

if(k.isdigit() and eval(k)<N*max_of_per_num and eval(k)>0 and max_of_per_num < 16 and max_of_per_num > 0):
    file = open("data","w")
    x=list(range(N))
    x=x*max_of_per_num
    for i in range(0,eval(k)):
        temp = random.randint(i,N*max_of_per_num-1)
        x[i],x[temp]=x[temp],x[i]
    for i in range(0,eval(k)):
        file.write(str(x[i])+"\n")
else:
    print("参数输入错误，请输入测试用例的数字个数（小于 “1000万*每个数的次数” 的正整数）和每个数最多出现的次数（不超过15，含15）。例如 dataGenerator.py 1000 1！")
```

## C语言实现
```c
#include <stdio.h>
#include <stdlib.h>

#define BITSPERWORD 32
#define SHIFT 5
#define MASK 0x1F
#define N 10000000
int a[1+N/BITSPERWORD];

void set(int i){        a[i >> SHIFT] |=  (1<<(i & MASK)); }
void clr(int i){        a[i >> SHIFT] &= ~(1<<(i & MASK)); }
int test(int i){ return a[i >> SHIFT] &   (1<<(i & MASK)); }

int main(){
    // freopen("data","r",stdin);
    // freopen ("output", "w", stdout);

    int i;
    for(i=0;i<N;i++){
        clr(i);
    }
    while(scanf("%d",&i)!=EOF){
        set(i);
    }

    for(i=0;i<N;i++){
        if(test(i))
            printf("%d\n",i);
    }
    return 0;
 }
```

## 拓展
&emsp;&emsp;第一章习题的第6题，将原问题中每个整数最多出现一次，改成每个整数最多出现10，其他条件不变的情况下应该怎么处理。
&emsp;&emsp;对于上述问题，只需要改变一下位向量的实现。使用每4位表示一个整数。下面给出的程序，忽略了内存大小的约束，用位图实现了每个整数最多出现10次时的排序算法。其中在用C语言实现算法时遇到了一个有趣的BUG。
```c
#include <stdio.h>
#include <stdlib.h>

#define BITSPERWORD 32
#define SHIFT 3
#define MASK 0x07
#define N 10000000
#define BITSPERNUM 4
#define SHOWMAX 10
unsigned int a[1+N/(BITSPERWORD/BITSPERNUM)];

void set(int i){        a[i >> SHIFT] +=  (1<<((i & MASK)*BITSPERNUM)); }
void clr(int i){        a[i >> SHIFT] &= ~(0x0f<<((i & MASK)*BITSPERNUM)); }
int test(int i){ return ( a[i >> SHIFT] &   (0x0f<<((i & MASK)*BITSPERNUM)) ) >> ((i & MASK)*BITSPERNUM); }

int main(){
    freopen("data","r",stdin);
    freopen ("output", "w", stdout);

    int i,j,c;
    for(i=0;i<N;i++){
        clr(i);
    }
    while(scanf("%d",&i)!=EOF){
        set(i);
    }

    for(i=0;i<N;i++){
        c = test(i);
        for (j=0;j<c;j++)
            printf("%d\n",i);
    }
    return 0;
 }

```
> 注：上述程序在实现过程中遇到一个BUG,那就是在一开始用int定义数组a。这导致在使用数据测试时，输出的整数个数少于输入的整数个数，即出现有测试数据“丢失”的情况，而且这个BUG只是有时出现，并且数据量越大，出现的概率越大。经过分析，发现问题主要出在void set(int i)这个函数，这个函数中使用了加法操作，这导致这种情况，1000 0000 0000 0001原本表示a,b,c,d分别出现了8，0，0，1次，而这是读入的数据又是d时，调用set函数，1000 0000 0000 0001 + 0000 0000 0000 0001 ，返回的值却是0。因为最高位是符号位，用十进制来看，set函数实际上返回的是(-1+1)的值
